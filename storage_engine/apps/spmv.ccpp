#define EXECUTABLE
#include "main.hpp"

struct createGraphDB1: public application {
  ////////////////////emitInitCreateDB////////////////////
  // init ColumnStores
  void run(){
    ColumnStore<long, long> *R = new ColumnStore<long, long>();
    std::vector<double> *annotation_R = new std::vector<double>();

    // init encodings
    SortableEncodingMap<long> *node_encodingMap = new SortableEncodingMap<long>();
    Encoding<long> *Encoding_node = new Encoding<long>();

    ////////////////////emitLoadColumnStore////////////////////
    {
      auto start_time = timer::start_clock();
      tsv_reader f_reader(
          "../../mkl/rma10/rma10.mtx");
      char *next = f_reader.tsv_get_first();
      while (next != NULL) {
        node_encodingMap->update(R->append_from_string<0>(next));
        next = f_reader.tsv_get_next();
        node_encodingMap->update(R->append_from_string<1>(next));
        next = f_reader.tsv_get_next();
        annotation_R->push_back(utils::from_string<double>(next));
        next = f_reader.tsv_get_next();
        R->num_rows++;
      }
      timer::stop_clock("READING ColumnStore R", start_time);
    }

    ////////////////////emitBuildEncodings////////////////////
    {
      auto start_time = timer::start_clock();
      Encoding_node->build(node_encodingMap->get_sorted());
      delete node_encodingMap;
      timer::stop_clock("BUILDING ENCODINGS", start_time);
    }

    std::vector<double> *annotation_A = new std::vector<double>();
    std::vector<std::vector<uint32_t>>* A = new std::vector<std::vector<uint32_t>>();
    {
      std::vector<uint32_t> aa;
      auto start_time = timer::start_clock();
      for(size_t i = 0; i < Encoding_node->num_distinct; i++){
        aa.push_back(i);
        annotation_A->push_back(0.25);
      }
      timer::stop_clock("BUILDING VECTOR", start_time);
      A->push_back(aa);
    }

    Trie<double,ParMemoryBuffer> *Trie_A = NULL;
    {
      auto start_time = timer::start_clock();
      // buildTrie
      std::vector<uint32_t> end;
      end.push_back(Encoding_node->num_distinct);
      Trie_A = new Trie<double,ParMemoryBuffer>( 
          "/Users/caberger/Documents/Research/data/databases/simple/db/relations/A/A_0",
          &end,
          A, 
          annotation_A);
      timer::stop_clock("BUILDING TRIE A_0", start_time);
    }

    ////////////////////emitEncodeColumnStore////////////////////
    EncodedColumnStore<double> *Encoded_R =
        new EncodedColumnStore<double>(annotation_R);
    {
      auto start_time = timer::start_clock();
      // encodeColumnStore
      Encoded_R->add_column(Encoding_node->encode_column(&R->get<0>()),
                            Encoding_node->num_distinct);
      Encoded_R->add_column(Encoding_node->encode_column(&R->get<1>()),
                            Encoding_node->num_distinct);
      timer::stop_clock("ENCODING R", start_time);
    }
    Trie<double,ParMemoryBuffer> *Trie_R_0_1 = NULL;
    {
      auto start_time = timer::start_clock();
      // buildTrie
      Trie_R_0_1 = new Trie<double,ParMemoryBuffer>( 
          "/Users/caberger/Documents/Research/data/databases/simple/db/relations/R/R_0_1",
          &Encoded_R->max_set_size,
          &Encoded_R->data, 
          &Encoded_R->annotation);
      timer::stop_clock("BUILDING TRIE R_0_1", start_time);
    }
    
    /*
    std::cout << "TRIE ORDERING 0 1" << std::endl;
    Trie_R_0_1->foreach([&](std::vector<uint32_t> *v, double a){
      for(size_t i = 0; i < v->size(); i++){
        std::cout << v->at(i) << " ";
      }
      std::cout << a << std::endl;
    });
    std::cout << "TRIE ORDERING 1 0" << std::endl;
    Trie_A->foreach([&](std::vector<uint32_t> *v, double a){
      for(size_t i = 0; i < v->size(); i++){
        std::cout << v->at(i) << " ";
      }
      std::cout << a << std::endl;
    });
      */
    ///loading finished matrix multiply code here.

    auto spmv = timer::start_clock();

  
    TrieBlock<hybrid,ParMemoryBuffer>* a = Trie_A->getHead();
    ////////////////////////////////////////////////////////////////////////////////////
    //Allocate the result trie and build the head
    Trie<double,ParMemoryBuffer>* result = new Trie<double,ParMemoryBuffer>("",1,true);
    ParMemoryBuffer* data_allocator = result->memoryBuffers;
    const Set<hybrid>* s1 = (const Set<hybrid>*)((uint8_t*)a+sizeof(TrieBlock<hybrid,ParMemoryBuffer>)); 
    const size_t block_size = s1->number_of_bytes+
      sizeof(TrieBlock<hybrid,ParMemoryBuffer>)+
      sizeof(Set<hybrid>);
    
    const size_t annotation_size = a->nextSize()*sizeof(double);
    uint8_t * const start_block = (uint8_t*)data_allocator->head->get_next(block_size+annotation_size);
    memcpy((uint8_t*)start_block,(uint8_t*)a,block_size);
    memset((uint8_t*)(start_block+block_size),(uint8_t)0,annotation_size);
    double* annotation = (double*)(start_block+block_size);
  
    ////////////////////////////////////////////////////////////////////////////////////

    Trie_R_0_1->getHead()->get_const_set()->par_foreach_index([&](const size_t tid, const uint32_t a_i, const uint32_t a_d){
      (void)tid;
      TrieBlock<hybrid,ParMemoryBuffer>* b = Trie_R_0_1->getHead()->get_next_block(a_i,a_d,Trie_R_0_1->memoryBuffers);
      double value = 0.0;
      b->get_const_set()->foreach_index([&](uint32_t b_i, uint32_t b_d){
        value += (b->get_annotation<double>(b_i,b_d)*Trie_A->getHead()->get_annotation<double>(b_i,b_d));
      });
      annotation[result->getHead()->get_index(a_i,a_d)] = value;
    });
    timer::stop_clock("SPMV", spmv);
    
    /*
    result->foreach([&](std::vector<uint32_t> *v, double a){
      if(a != 0){
        for(size_t i = 0; i < v->size(); i++){
          std::cout << v->at(i) << " ";
        }
        std::cout << a << std::endl;
      }
    });
    */

  }
};

application* init_app(){
  return new createGraphDB1(); 
}